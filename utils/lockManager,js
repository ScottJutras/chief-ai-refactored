const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

const DEFAULT_TTL_SEC = 25;

/**
 * Try to acquire an expiring lock for user_id.
 * - If existing lock is expired, steal it.
 * - If the same token arrives (retry), allow re-entry.
 * Returns true if acquired, false otherwise.
 */
async function acquireLock(userId, token, ttlSec = DEFAULT_TTL_SEC) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Check current lock
    const { rows } = await client.query(
      `SELECT token, expires_at FROM locks WHERE user_id = $1 FOR UPDATE`,
      [userId]
    );

    const now = new Date();
    const newExpiry = new Date(now.getTime() + ttlSec * 1000);

    if (rows.length === 0) {
      // No lock -> insert new
      await client.query(
        `INSERT INTO locks (user_id, token, expires_at, updated_at)
         VALUES ($1, $2, $3, NOW())`,
        [userId, token, newExpiry]
      );
      await client.query('COMMIT');
      return true;
    }

    const current = rows[0];
    const expired = new Date(current.expires_at) <= now;
    const sameToken = current.token === token;

    if (expired || sameToken) {
      // Steal/refresh the lock or re-enter idempotently
      await client.query(
        `UPDATE locks
           SET token = $2, expires_at = $3, updated_at = NOW()
         WHERE user_id = $1`,
        [userId, token, newExpiry]
      );
      await client.query('COMMIT');
      return true;
    }

    // Someone else holds an unexpired lock
    await client.query('ROLLBACK');
    return false;
  } catch (e) {
    await client.query('ROLLBACK');
    throw e;
  } finally {
    client.release();
  }
}

/**
 * Release the lock if owned by the same token (so parallel requests canâ€™t clobber).
 * If token is unknown, do nothing (best-effort).
 */
async function releaseLock(userId, token) {
  try {
    await pool.query(
      `DELETE FROM locks WHERE user_id = $1 AND token = $2`,
      [userId, token]
    );
  } catch (e) {
    // swallow; don't crash webhook on release failure
  }
}

module.exports = { acquireLock, releaseLock };